# 3.5. 인덱스 설계

## 3.5.1. 인덱스의 개념
**인덱스**는 데이터 레코드를 빠르게 접근하기 위해, <키 값, 포인터> 쌍으로 구성되는 데이터 구조다.
- 데이터가 저장된 물리적 구조와 밀접한 관꼐가 있다.
- 레코드가 저장된 물리적 구조에 접근하는 방법을 제공한다.
- 기본키를 위한 인덱스를 **기본 인덱스**라 하고, 기본 인덱스가 아닌 인덱스들을 **보조 인덱스**라고 한다.
- 레코드의 물리적 순서가 인덱스의 엔트리 순서와 일치하게 유지되도록 구성되는 인덱스를 **클러스터드 인덱스**라고 한다.
- 인덱스를 구성하는 구조나 특징에 따라 **트리 기반 인덱스**, **비트맵 인덱스**, **함수 기반 인덱스**, **비트맵 조인 인덱스**, **도메인 인덱스** 등으로 분류된다.

### 3.5.1.1. 트리 기반 인덱스
<u>인덱스를 저장하는 블록들이 트리 구조를 이루고 있는 것</u>으로, 상용 DBMS에서는 트리 구조 기반의 B+ 트리 인덱스를 주로 활용한다.
- **B 트리 인덱스**
  - 일반적으로 사용되는 인덱스 반식으로, 루트 노드에서 하위노드로 키 값의 크기를 비교해 나가면서 단말 노드에서 찾고자 하는 데이터를 검색한다.
  - 키 값과 레코드를 가리키는 포인터들이 트리 노드에 오름차순으로 저장된다.
  - 모든 리프 노드는 같은 레벨에 있다.
- **B+ 트리 인덱스**
  - B+ 트리는 B 트리의 변형으로, 단말 노드가 아닌 노드로 구성된 인덱스 세트와 단말 노드로만 구성된 순차 세트로 구분된다.
  - 인덱스 세트에 있는 노드들은 단말 노드에 있는 키 값을 찾아갈 수 있는 경로로만 제공되며, 순차 세트에 있는 단말 노드가 해당 데이터 레코드의 주소를 가리킨다.
  - 인덱스 세트에 있는 모든 키 값이 단말 노드에 다시 나타나므로, 단말 노드만을 이용한 순차 처리가 가능하다.

### 3.5.1.2. 비트맵 인덱스
<u>인덱스 컬럼의 데이터를 Bit 값인 0 또는 1로 변환</u>하여, 인덱스키로 사용하는 방법이다.
- 비트맵 인덱스의 목적은 키 값을 포함하는 로우(Row)의 주소를 제공하는 것이다.
- 분포도가 좋은 컬럼에 적합하며, 성능 향상 효과를 얻을 수 있다.
- 데이터가 Bit로 구성되어 있기 때문에, 효율적인 논리 연산이 가능하고 저장 공간이 작다.
- 다중 조건을 만족하는 튜플의 개수 계산에 적합하다.
- 동일한 값이 반복되는 경우가 많아 압축 효율이 좋다.

### 3.5.1.3. 함수 기반 인덱스
<u>컬럼의 값 대신 컬럼에 특정 함수나 수식을 적용하여 산출된 값을 사용</u>하는 것으로, B+ 트리 인덱스 또는 비트맵 인덱스를 생성하여 사용한다.
- 데이터를 입력하거나 수정할 때 함수를 적용해야 하므로 부하가 발생할 수 있다.
- 사용된 함수가 사용자 정의 함수일 경우, 시스템 함수보다 부하가 더 크다.
- 대소문자, 띄어쓰기 등에 상관없이 조회할 때 유용하게 사용된다.
- 적용 가능한 함수의 종류
  - 산술식, 사용자 정의 함수, PL/SQL 함수, SQL 함수, 패키지, C callout 등

### 3.5.1.4. 비트맵 조인 인덱스
<u>다수의 조인된 객체로 구성</u>된 인덱스로, 단일 객체로 구성된 일반적인 인덱스와 액세스 방법이 다르다.
- 비트맵 인덱스와 물리적인 구조가 동일하다.

### 3.5.1.5. 도메인 인덱스
<u>개발자가 필요한 인덱스를 직접 만들어 사용</u>하는 것으로, **확장형 인덱스**라고도 한다.
- 개발자가 필요에 의해 만들었지만, 프로그램에서 제공하는 인덱스처럼 사용할 수도 있다.

## 3.5.2. 인덱스 설계
인덱스를 설계할 때는 분명하게 드러난 컬럼에 대해 기본적인 인덱스를 먼저 지정한 후, 개발 단계에서 필요한 인덱스의 설계를 반복적으로 진행한다.
- 인덱스 설계 순서
  1. 인덱스의 대상 테이블이나 컬럼 등을 선정한다.
  2. 인덱스의 효율성을 검토하여 인덱스 최적화를 수행한다.
  3. 인덱스 정의서를 작성한다.

### 3.5.2.1. 인덱스 대상 테이블 선정 기준
- MULTI BLOCK READ 수에 따라 판단.
- 랜덤 액세스가 빈번한 테이블
- 특정 범위나 특정 순서로 데이터 조회가 필요한 테이블
- 다른 테이블과 순차적 조인이 발생되는 테이블

### 3.5.2.2. 인덱스 대상 컬럼 선정 기준
- 인덱스 컬럼의 분포도가 10~15% 이내인 컬럼
  - 분포도 = (컬럼 값의 평균 Row 수 / 테이블의 총 Row 수) × 100
- 분포도가 10~15% 이상이어도 부분 처리를 목적으로 하는 컬럼
- 입·출력 장표 등에서 조회 및 출력 조건으로 사용되는 컬럼
- 인덱스가 자동 생성되는 기본키와 유일키 제약 조건을 사용한 컬럼
- 가능함 수정이 빈번하지 않은 컬럼
- ORDER BY, GROUP BY, UNION이 빈번한 컬럼
- 분포도가 좁은 컬럼은 단독 인덱스로 생성
- 인덱스들이 자주 조합되어 사용되는 경우, 하나의 결합 인덱스로 생성

### 3.5.2.3. 인덱스 설계 시 고려 사항
- 새로 추가되는 인덱스는 기존 액세스 경로에 영향을 미칠 수 있다.
- 인덱스를 지나치게 많이 만들면 오버헤드가 발생한다.
- 넓은 범위를 인덱스로 처리하면 많은 오버해드가 발생한다.
- 인덱스를 만들면 추가적인 저장 공간이 필요하다.
- 인덱스와 테이블 데이터 저장 공간이 분리되도록 설계한다.